Compilers translate a sequence of high-level instructions (program) into a functionally equivalent sequence of low-level native gates (assembly). Qubit mapping and routing are two fundamental steps involved in this process.

\tcbline{}

\begin{question}
    How does the quality of initial qubit mapping or allocation impact the performance of the quantum computer for a given application?
\end{question}
\textbf{Answer.} The initial qubit mapping determines the relative positions of the qubits. This is crucial to the routing decisions since qubits have limited connectivity, usually in a grid-like layout. Thus, if a pair of qubits that have a lot of 2-qubit gates between them are located far away, we would require a larger number of swap operations than if they were located close by. This would increase the execution time of the program and hence increase the decoherence error. Additionally, the number of gates would also increase the accumulated error and hence the program accuracy would also decrease.

\tcbline{}

\begin{question}
    How does the routing policy impact the quality of the solutions for a given application?
\end{question}
\textbf{Answer.} A bad routing policy would require more swap operations for each two-qubit (or multi-qubit) gate to place the associated qubits next to each other. On the other hand, a good routing policy would reduce the number of swap operations required significantly thus improving the quantum program run time. This would also reduce the decoherence error since a reduced execution time between measurements would reduce the effects of decoherence. Additionally, lesser gates also imply lesser accumulated errors thus increasing the program accuracy.\par
Different routing policies are implemented for different use cases, some might be implemented for machines that have a lower decoherence time or some that might have higher gate error rates. Similarly, the routing policy might also favour some applications over the others. For example, a routing policy might optimize for the number of swap operations required for a given program while another might optimize for the execution time of the program. Thus, the choice of the routing policy will affect the performance of the quantum computer for a given application.

\tcbline{}

\begin{question}
    There exists numerous routing policies in the compilation space. Why? Which would you like to opt for in order to run any given program of your choice?
\end{question}
\textbf{Answer.} Different routing policies operate at different levels of space and time versus the quality of the routing. The solver based routing policies take exponential space and time however they give the best routing possible for any program. On the other hand routing policies like SABRE take very little space and time, but they do not guarantee the best routing possible and there are bound to be programs that will perform very poorly in execution time and/or accuracy when compiled with SABRE's routing policy. A different routing policy that maintains a working set of solutions and constantly prunes it (like ForeSight), takes more space and time in comparison to SABRE but guarantees better routing.\par
Thus, the choice of the routing policy can be determined by the required goals. If we want very low runtimes with higher accuracies, then we would want to choose the solver based approach. However, if we want to reduce the space and time complexity of the routing algorithm, then we would want to choose a routing policy like SABRE. If we want to have a balance between the two, then we would want to choose a routing policy like ForeSight.

\tcbline{}

\begin{question}
    What are the trade-offs involved in routing overheads and device topology?
\end{question}
\textbf{Answer.} If the device has a simpler topology with limited connectivity, then the routing algorithms will have reduced complexity and hence the routing problem will be much simpler. On the other hand, if the device has larger connectivity, there are multiple paths to perform swaps between two pairs of qubits and hence the routing problem requires larger computation. Even if the connectivity remains the same but the number of qubits in the device are increased, the routing becomes more complex and will lead to larger overheads.